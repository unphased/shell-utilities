#!/usr/bin/env perl

use strict;
use warnings;

use IO::Pty::Easy;
use Term::ReadKey;
use Encode;

if ( $#ARGV >= 0 && grep ($ARGV[0] eq $_,("-h", "--help", "help"))) {
# if ($ARGV[0] ~~ ["h", "-h", "--help", "help"]) {
    print "Usage: $0 (-h|--help|help)|(code_in codes_out [code_in codes_out]+)\nNote: output codes can be arbitrary length\n";
    exit;
}

$#ARGV % 2 and die "Odd number of args required.\n";

if ($#ARGV == -1) {
    warn ("No args provided. A command must be specified.\n");
    exit 1;
}

# be sure to enter the command as a string
my %mapping = @ARGV[-@ARGV..-2];

my $interactive = -t STDIN;

# my %mapping = @ARGV;
# my @mapkeys = keys %mapping;

# warn @mapkeys;
if ($interactive) {
    print "Spawning command in pty: @ARGV\n"
    # print "\nContinue? (y/n)";
    # my $y_n;
    # while (($y_n = <STDIN>) !~ /^(y|n)$/) {
    #     print '(y/n)';
    # }
    # exit if $y_n eq "n\n";
} else {
    print 'Not invoked from interactive terminal: Please use sed instead. Continuing.';
}

my $pty = IO::Pty::Easy->new((raw => !!$interactive));
my $spawnret = $pty->spawn("@ARGV")."\n";

print STDERR "Spawning has failed: @ARGV\n" if !$spawnret;

ReadMode 4;
END {
    ReadMode 0; # Reset tty mode before exiting
}

my $i = undef;
my $j = 0;

{
    local $| = 1;
    while (1) {
        myread();

        # responsive to key input, and pty output may be behind by 50ms
        my $key = ReadKey(0.05);
        # last if !defined($key) || !$key;
        if (defined($key)) {
            my $code = ord($key); # this byte is...
            if ($interactive and $code == 4) {
                # User types Ctrl+D
                print STDERR "Saw ^D from term, embarking on filicide with TERM signal\n";
                $pty->kill("TERM", 0); # blocks till death of child
                myread();
                $pty->close();
                last;
            }
            printf("saw %s: \\x%02X\n", $key, $code);

            # echo translated input to pty
            if ($key eq "a") {
                $pty->write("zzz"); # print 'Saw "a", wrote "zzz" to pty';
            } else {
                $pty->write($key); # print "Wrote to pty: $key";
            }
        }
    }
}

sub myread {
    # read out pty's activity to echo to stdout
    my $from_pty = $pty->read(0);
    if (defined($from_pty)) {
        if ($from_pty) {
            # print "read from pty -->$from_pty<--\n";
            print $from_pty;
        } else {
            if ($from_pty eq '') {
                # empty means EOF means pty has exited, so I exit because my fate is sealed
                print STDERR "Got back from pty EOF, quitting\n" if $interactive;
                $pty->close();
                last;
            }
        }
    }
}