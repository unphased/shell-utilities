#!/usr/bin/env perl

# This is an input mapper. I have (had?) it hardcoded for munging mouse scroll
# to translate the escape codes from the terminal into keypresses.
# It may be worthwhile to generalize the translation logic into args.

use strict;
use warnings;

use IO::Pty::Easy;
use Term::ReadKey;
use Encode;

# if ( $#ARGV >= 0 && grep ($ARGV[0] eq $_,("-h", "--help", "help"))) {
# # if ($ARGV[0] ~~ ["h", "-h", "--help", "help"]) {
#     print "Usage: $0 (-h|--help|help)|(code_in codes_out [code_in codes_out]* command)\nNote: codes can be arbitrary length strings\n";
#     exit;
# }

my $nomouse = grep /--nomouse/, @ARGV;
@ARGV = grep ! /--nomouse/, @ARGV;

$#ARGV % 2 and die "Odd number of args required.\n";

if ($#ARGV == -1) {
    warn ("No args provided. A command must be specified.\n");
    exit 1;
}

# be sure to enter the command as a string
my %mapping = @ARGV[-@ARGV..-2];

my $cmd = $ARGV[$#ARGV];

my $interactive = -t STDIN;

warn %mapping;
warn @ARGV;

if ($interactive) {
    print "Spawning command in pty: $cmd\n"
    # print "\nContinue? (y/n)";
    # my $y_n;
    # while (($y_n = <STDIN>) !~ /^(y|n)$/) {
    #     print '(y/n)';
    # }
    # exit if $y_n eq "n\n";
} else {
    print 'map: Not invoked from interactive terminal: Please use sed instead. EOF handling will be bad. Continuing.';
}

my $pty = IO::Pty::Easy->new((raw => !!$interactive));
my $spawnret = $pty->spawn($cmd)."\n";

print STDERR "Spawning has failed: $cmd\n" if !$spawnret;

ReadMode 4;
END {
    ReadMode 0; # Reset tty mode before exiting
    print "\x1b[?1000l" if !$nomouse; # disable mouse mode
}
print "\x1b[?1000h" if !$nomouse; # enable mouse mode

my $i = undef;
my $j = 0;

{
    local $| = 1;
    while (1) {
        myread();

        # responsive to key input, and pty output may be behind by 50ms
        my $key = ReadKey(0.05);
        # last if !defined($key) || !$key;
        if (defined($key)) {
            my $code = ord($key); # this byte is...
            if ($interactive and $code == 4) {
                # User types Ctrl+D
                print STDERR "Saw ^D from term, embarking on filicide with TERM signal\n";
                $pty->kill("TERM", 0); # blocks till death of child
                myread();
                $pty->close();
                last;
            }
            printf("saw %s: \\x%02X\n", $key, $code);

            # echo translated input to pty
            if ($key eq "a") {
                $pty->write("zzz"); # print 'Saw "a", wrote "zzz" to pty';
            } else {
                $pty->write($key); # print "Wrote to pty: $key";
            }
        }
    }
}

sub myread {
    # read out pty's activity to echo to stdout
    my $from_pty = $pty->read(0);
    if (defined($from_pty)) {
        if ($from_pty) {
            # print "read from pty -->$from_pty<--\n";
            print $from_pty;
        } else {
            if ($from_pty eq '') {
                # empty means EOF means pty has exited, so I exit because my fate is sealed
                print STDERR "Got back from pty EOF, quitting\n" if $interactive;
                $pty->close();
                last;
            }
        }
    }
}