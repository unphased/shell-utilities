#!/usr/bin/env perl

use strict;
use warnings;

use IO::Pty::Easy;
use Term::ReadKey;
ReadMode 4;
END {
    ReadMode 0; # Reset tty mode before exiting
}

if ( $#ARGV >= 0 && grep ($ARGV[0] eq $_,("-h", "--help", "help"))) {
# if ($ARGV[0] ~~ ["h", "-h", "--help", "help"]) {
    print "Usage: $0 (-h|--help|help)|(code_in codes_out [code_in codes_out]+)\nNote: output codes can be arbitrary length\n";
    exit;
}

# $#ARGV % 2 or die "Even number of args required.\n";

# $#ARGV >= 0 or warn "No args provided. Output should be identical to input.\n";

my $interactive = -t STDIN;

# my %mapping = @ARGV;
# my @mapkeys = keys %mapping;

# warn @mapkeys;

# testing pty here
my $pty = IO::Pty::Easy->new;
print "pty->spawn returns: ".$pty->spawn("@ARGV");

my $i = undef;
my $j = 0;

{
    local $| = 1;
    while (1) {
        my $key = ReadKey(0);
        last if !defined($key) || !$key;
        my $code = ord($key); # this byte is...
        # if (!defined ($i)) {
            # begin search
            # for (;$j <= $#mapkeys; ++$j) {
                # print "$mapkeys[$j] is $mapping{$mapkeys[$j]}\n"

            # }
        # }
        # printf("saw %s: \\x%02X\n", $key, $code);

		# read out pty's activity
		my $from_pty = $pty->read(0);
		if (defined($from_pty)) {
			if ($from_pty) {
				print "read from pty -->$from_pty<--\n";
			} else {
				if ($from_pty eq '') {
					# empty means EOF means pty has exited, so I exit because my fate is sealed
					print STDERR "Got back from pty EOF, quitting\n"
					exit 0;
				}
			}
		}

		# echo translated input to pty
        if ($key eq "a") {
            $pty->write("zzz"); print 'Saw "a", wrote "zzz" to pty';
        } else { $pty->write($key); print "Wrote to pty: $key"; }
        if ($interactive and $code == 4) {
            # User types Ctrl+D
			print STDERR "Saw ^D from term, quitting\n"
            last;
        }
    }
}

